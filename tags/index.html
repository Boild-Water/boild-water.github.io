<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>BoildWater</title>
<link rel="shortcut icon" href="/favicon.ico?v=1661909029725">
<link rel="stylesheet" href="/media/css/mist.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="mist">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="">
              <span class="logo-line-before">
                <i class=""></i>
              </span>
              <span class="main-title">BoildWater</span>
              <span class="logo-line-after">
                <i class=""></i>
              </span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout bg-color mist">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper ">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">我是谁</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">2</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">2</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'mist';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box box-shadow-wrapper">
          <section class="section tags-section bg-color posts-expand">
            <div class="tags-box">
  <div class="tag-cloud-title language" data-lan="cloud-tags" data-count="2">
    非常好！目前共计 2 个标签，继续努力！
  </div>
  <div class="tag-cloud-list" id="tags">
    
      
      
        
      
        
      
        
          
            
      
        
          
        
      
      <a class="cloud-tag" href="https://boild-water.github.io/tag/NUKtFG5DTG/" rel="1">图片服务器</a>
    
      
      
        
      
        
      
        
          
        
          
            
      
        
          
        
      
      <a class="cloud-tag" href="https://boild-water.github.io/tag/bKxH71k96j/" rel="1">Apache Server</a>
    
  </div>
</div>
<script>

  let fontStart = 12, fontEnd = 30, colorStart = '#666', colorEnd = '#000';
  let tags = document.querySelector('#tags').children;
  let counts = [];
  for(let i = 0; i < tags.length; i++) {
    counts.push(tags[i].rel);
  }
  let lowest = Math.min.apply(null,counts), highest = Math.max.apply(null,counts);;
  let range = highest - lowest;
  if (range === 0) {
    range = 1;
  }
  let fontIncr, colorIncr;
  fontIncr = (fontEnd - fontStart) / range;
  
  let sColorArr = toRGB(colorStart), eColorArr = toRGB(colorEnd);

  for(let i = 0; i < tags.length; i++) {
    let disCount = tags[i].rel - lowest;
    let fontSize = fontStart + disCount * fontIncr;
    let style = 'font-size: ' + fontSize + 'px;';
    let arr = [];
    for(let c = 0; c < sColorArr.length; c++) {
      if (disCount === 0) {
        disCount = 1;
      }
      let val = (sColorArr[c] - eColorArr[c]) / range * disCount;
      if (val >= 100) {
        val = eColorArr[c];
      } else if (val <= 0) {
        val = sColorArr[c];
      }
      arr[c] = Math.floor(val);
    }
    style += 'color: ' + toHex(arr);
    tags[i].style = style;
  }

  function toRGB(code) {
    if (code.length === 4) {
      code = code.replace(/(\w)(\w)(\w)/gi, "\$1\$1\$2\$2\$3\$3");
    }
    var hex = /(\w{2})(\w{2})(\w{2})/.exec(code);
    return [parseInt(hex[1], 16), parseInt(hex[2], 16), parseInt(hex[3], 16)];
  }

  function toHex(ary) {
    return "#" + ((1 << 24) + (ary[0] << 16) + (ary[1] << 8) + ary[2]).toString(16).slice(1);
  }

</script>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
      <div class="drawer-box right" id="drawer_box">
        <span class="muse-line muse-line-first"></span>
        <span class="muse-line muse-line-middle"></span>
        <span class="muse-line muse-line-last"></span>
      </div>
      
        <div class="mist back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://boild-water.github.io/post/java-lei-jia-zai/"" data-c="
          &lt;h4 id=&#34;一-前言&#34;&gt;一、前言&lt;/h4&gt;
&lt;p&gt;最近看spring源码，想深入探究一下spring中的&lt;code&gt;&amp;quot;classpath*:&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;classpath:&amp;quot;&lt;/code&gt;写法的区别，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ApplicationContext ac = new ClassPathXmlApplicationContext(&amp;quot;classpath*:spring*&amp;quot;);
ApplicationContext ac = new ClassPathXmlApplicationContext(&amp;quot;classpath:spring*&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别就在于&lt;code&gt;classpath*&lt;/code&gt;会查找&lt;code&gt;java.class.path&lt;/code&gt;下所有符合&lt;code&gt;spring*&lt;/code&gt;样式的文件并加载，因为引入的第三方依赖打包的jar也在&lt;code&gt;java.class.path&lt;/code&gt;下，如果某个jar中含有同路径文件，也会被找到，而&lt;code&gt;classpath&lt;/code&gt;只会找到当前项目的&lt;code&gt;classpath&lt;/code&gt;下与&lt;code&gt;spring*&lt;/code&gt;样式匹配的多个文件，看了下源码的区别&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResources  
@Override
public Resource[] getResources(String locationPattern) throws IOException {
  Assert.notNull(locationPattern, &amp;quot;Location pattern must not be null&amp;quot;);
  if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
    // a class path resource (multiple resources for same name possible)
    if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
      // a class path resource pattern
      return findPathMatchingResources(locationPattern);
    }
    else {
      // classpath*的写法最终会执行findAllClassPathResources方法
      // findAllClassPathResources方法中调用了 classLoader.getResources(path)方法，可以查找到多个文件，构造多个资源对象返回
      // all class path resources with the given name
      return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
    }
  }
  else {
    // Generally only look for a pattern after a prefix here,
    // and on Tomcat only after the &amp;quot;*/&amp;quot; separator for its &amp;quot;war:&amp;quot; protocol.
    int prefixEnd = (locationPattern.startsWith(&amp;quot;war:&amp;quot;) ? locationPattern.indexOf(&amp;quot;*/&amp;quot;) + 1 :
                     locationPattern.indexOf(&#39;:&#39;) + 1);
    if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {
      // a file pattern
      return findPathMatchingResources(locationPattern);
    }
    else {
      // classpath的写法最终会执行到这里
      // org.springframework.core.io.DefaultResourceLoader#getResource中，直接new了一个ClassPathResource对象出来
      // a single resource with the given name
      return new Resource[] {getResourceLoader().getResource(locationPattern)};
    }
  }
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为对classLoader.getResource(path)和classLoader.getResources(path)的不熟悉，所以就去搜索了相关信息。然后，就对ClassLoader产生了兴趣。&lt;/p&gt;
&lt;h5 id=&#34;1-一个java程序的日常开发过程&#34;&gt;1、一个Java程序的日常开发过程&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;1、编写.java文件&lt;/p&gt;
&lt;p&gt;2、将写好的java代码打包成jar包或者war包，即编译代码，包里面就是.java文件对应的.class文件&lt;/p&gt;
&lt;p&gt;3、使用命令“java -jar”运行打包好的程序，即运行代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;2-java文件的运行过程&#34;&gt;2、Java文件的运行过程&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;二-java类加载过程&#34;&gt;二、Java类加载过程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/view.png&#34; alt=&#34;preview&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;1-loading加载&#34;&gt;1、Loading加载&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;通过类的全限定名（包名 + 类名），获取到该类的&lt;code&gt;.class&lt;/code&gt;文件的二进制字节流&lt;/p&gt;
&lt;p&gt;将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;内存&lt;/code&gt;中生成一个代表该类的&lt;code&gt;java.lang.Class&lt;/code&gt;对象，作为方法区这个类的各种数据的访问入口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：&lt;code&gt;加载二进制数据到内存&lt;/code&gt; —&amp;gt; &lt;code&gt;映射成jvm能识别的结构&lt;/code&gt; —&amp;gt; &lt;code&gt;在内存中生成class文件&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&#34;2-linking链接&#34;&gt;2、Linking链接&lt;/h5&gt;
&lt;p&gt;链接是指将上面创建好的class类合并至Java虚拟机中，使之能够执行的过程，可分为&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;三个阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 验证（Verify）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;② 准备（Prepare）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为类中的&lt;code&gt;静态字段&lt;/code&gt;分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;③ 解析（Resolve）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解析阶段的目的，是将常量池内的符号引用转换为直接引用的过程（将常量池内的符号引用解析成为实际引用）。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）&lt;/p&gt;
&lt;p&gt;事实上，解析器操作往往会伴随着 JVM 在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。&lt;/p&gt;
&lt;p&gt;解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;3-initialization初始化&#34;&gt;3、initialization初始化&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;初始化就是执行类的构造器方法 &lt;code&gt;init()&lt;/code&gt;的过程。&lt;/p&gt;
&lt;p&gt;这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。&lt;/p&gt;
&lt;p&gt;若该类具有父类，&lt;code&gt;jvm&lt;/code&gt;会保证父类的&lt;code&gt;init&lt;/code&gt;先执行，然后在执行子类的&lt;code&gt;init&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;三-java类加载器classloader&#34;&gt;三、Java类加载器ClassLoader&lt;/h4&gt;
&lt;h5 id=&#34;1-类加载器分类&#34;&gt;1、类加载器分类&lt;/h5&gt;
&lt;p&gt;JVM的类加载是通过ClassLoader及其子类来完成的，类加载器的层级与关系如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/de9a45043712043c0700e5cc548218cb.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意这里的父子并不是继承的意思，它们都是&lt;code&gt;ClassLoader&lt;/code&gt;抽象类的实现，因此都含有一个&lt;code&gt;ClassLoader parent&lt;/code&gt;成员变量，该变量指向其父加载器，类似单向链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 启动类/引导类：Bootstrap ClassLoader&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个类加载器使用C/C++语言实现的，嵌套在JVM内部，java程序无法直接操作这个类。&lt;/p&gt;
&lt;p&gt;它用来加载Java核心类库，如：&lt;code&gt;JAVA_HOME/jre/lib/rt.jar&lt;/code&gt;、&lt;code&gt;resources.jar&lt;/code&gt;、&lt;code&gt;sun.boot.class.path&lt;/code&gt;路径下的包，用于提供jvm运行所需的包。&lt;/p&gt;
&lt;p&gt;并不是继承自java.lang.ClassLoader，它没有父类加载器&lt;/p&gt;
&lt;p&gt;它加载&lt;code&gt;扩展类加载器&lt;/code&gt;和&lt;code&gt;应用程序类加载器&lt;/code&gt;，并成为他们的父类加载器&lt;/p&gt;
&lt;p&gt;出于安全考虑，启动类只加载包名为：java、javax、sun开头的类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;② 扩展类加载器：Extension ClassLoader&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java语言编写，由&lt;code&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt;实现，我们可以用Java程序操作这个加载器&lt;/p&gt;
&lt;p&gt;派生继承自java.lang.ClassLoader，父类加载器为&lt;code&gt;启动类加载器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从系统属性：&lt;code&gt;java.ext.dirs&lt;/code&gt;目录中加载类库，或者从JDK安装目录：&lt;code&gt;jre/lib/ext&lt;/code&gt;目录下加载类库。我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;③ 应用程序类加载器：Application Classloader&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java语言编写，由&lt;code&gt;sun.misc.Launcher$AppClassLoader&lt;/code&gt;实现&lt;/p&gt;
&lt;p&gt;派生继承自java.lang.ClassLoader，父类加载器为&lt;code&gt;启动类加载器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它负责加载&lt;code&gt;环境变量classpath&lt;/code&gt;或者&lt;code&gt;系统属性java.class.path&lt;/code&gt;指定路径下的类库&lt;/p&gt;
&lt;p&gt;它是程序中默认的类加载器，我们Java程序中的类，都是由它加载完成的。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;ClassLoader#getSystemClassLoader()&lt;/code&gt;获取并操作这个加载器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;④ 自定义加载器&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般情况下，以上3种加载器能满足我们日常的开发工作，不满足时，我们还可以&lt;code&gt;自定义加载器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要&lt;code&gt;自定义加载器&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;2-类加载机制-双亲委派&#34;&gt;2、类加载机制-双亲委派&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）如果一个&lt;code&gt;类加载器&lt;/code&gt;接收到了&lt;code&gt;类加载&lt;/code&gt;的请求，它自己不会先去加载，会把这个请求委托给&lt;code&gt;父类加载器&lt;/code&gt;去执行。&lt;/p&gt;
&lt;p&gt;（2）如果父类还存在父类加载器，则继续向上委托，一直委托到&lt;code&gt;启动类加载器：Bootstrap ClassLoader&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（3）如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出&lt;code&gt;ClassNotFoundException&lt;/code&gt;异常，这就是&lt;code&gt;双亲委派模式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loadClass()&lt;/code&gt;是抽象类&lt;code&gt;ClassLoader&lt;/code&gt;中的类加载的核心方法，该段代码就是双亲委派的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException
{
  synchronized (getClassLoadingLock(name)) {
    // 若该类已被加载过，直接取缓存，native方法实现
    Class c = findLoadedClass(name);
    if (c == null) {
      try {
        // 只要有父加载器就先委派父加载器来加载
        if (parent != null) {
          // 注意此处递归调用
          c = parent.loadClass(name, false);
        } else {
          // ext的parent为null，因为Bootstrap是无法被程序被访问的，默认parent为null时其父加载器就是Bootstrap
          // 此时直接用native方法调用启动类加载加载，若找不到则抛异常
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // 对ClassNotFoundException不做处理，仅用作退出递归
      }
      if (c == null) {
        // 如果父加载器无法加载那么就在本类加载器的范围内进行查找
        // findClass找到class文件后将调用defineClass方法把字节码导入方法区，同时缓存结果
        c = findClass(name);
      }
    }
    // 是否解析，默认false
    if (resolve) {
      resolveClass(c);
    }
    return c;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-类加载特点&#34;&gt;3、类加载特点&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;全盘负责&lt;/strong&gt;，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父类委托&lt;/strong&gt;，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存机制&lt;/strong&gt;，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效，当然也可以不重启JVM，详情见下面介绍的&lt;code&gt;HotSwap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;沙箱安全&lt;/strong&gt;，比如开发者可以自定义一个类，就叫做&lt;code&gt;java.lang.String&lt;/code&gt;，在这个类中写上自己的逻辑，代码编译也是能过的，但是运行的时候就会报错，原因就在于类加载的时候根本就不会去加载这个自定义的类，因为在jdk的类库中是存在&lt;code&gt;java.lang.String&lt;/code&gt;类的，是被&lt;code&gt;顶级引导类加载器(Bootstrap ClassLoader)&lt;/code&gt;加载。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;4-获取classloader几种方式&#34;&gt;4、获取ClassLoader几种方式&lt;/h5&gt;
&lt;p&gt;它是一个抽象类，其后所有的类加载器继承自 ClassLoader（不包括启动类加载器）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 方式一：获取当前类的 ClassLoader
clazz.getClassLoader()
// 方式二：获取当前线程上下文的 ClassLoader
Thread.currentThread().getContextClassLoader()
// 方式三：获取系统的 ClassLoader
ClassLoader.getSystemClassLoader()
// 方式四：获取调用者的 ClassLoader
DriverManager.getCallerClassLoader()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;5-自定义类加载器&#34;&gt;5、自定义类加载器&lt;/h5&gt;
&lt;p&gt;通常情况下，都是直接使用系统类加载器。但是有的时候，也需要自定义类加载器。比如应用通过网络来传输Java类的字节码，为保证&lt;strong&gt;安全性，&lt;strong&gt;这些字节码经过了&lt;/strong&gt;加密处理&lt;/strong&gt;，这时系统类加载器就无法对其进行加载，因为这些字节码文件可以存放在网络上的各个地方，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自&lt;code&gt;ClassLoader&lt;/code&gt;类，从上面对 &lt;code&gt;loadClass&lt;/code&gt;方法来分析来看，只需要重写 &lt;code&gt;findClass&lt;/code&gt;方法即可。&lt;/p&gt;
&lt;p&gt;下面通过一个示例来演示自定义类加载器的流程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClassLoader extends ClassLoader { 
  
   private String root; 
  
   protected Class&amp;lt;?&amp;gt; findClass(String name) throwsClassNotFoundException {
       byte[] classData = loadClassData(name);
       if (classData == null) {
           throw new ClassNotFoundException();
       } else {
            return defineClass(name, classData, 0,classData.length);
       }
    }
 
   private byte[] loadClassData(String className) {
       String fileName = root + File.separatorChar
                + className.replace(&#39;.&#39;,File.separatorChar) + &amp;quot;.class&amp;quot;;
       try {
           InputStream ins = new FileInputStream(fileName);
           ByteArrayOutputStream baos = new ByteArrayOutputStream();
           int bufferSize = 1024;
            byte[] buffer = new byte[bufferSize];
           int length = 0;
           while ((length = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, length);
           }
           return baos.toByteArray();
       } catch (IOException e) {
           e.printStackTrace();
       }
       return null;
    }
 
   public String getRoot() {
       return root;
    }
 
   public void setRoot(String root) {
       this.root = root;
    }
 
   public static void main(String[] args) {
 
       MyClassLoader classLoader = new MyClassLoader();
       
       Class&amp;lt;?&amp;gt; testClass = null;
       try {
         	 // 可以指定任意本地目录下的class文件或者远程地址等，将其加载到JVM中
           classLoader.setRoot(&amp;quot;E:\\temp&amp;quot;);
           testClass =classLoader.loadClass(&amp;quot;org.example.classloader.Test&amp;quot;);
           Object object = testClass.newInstance();
           System.out.println(object.getClass().getClassLoader());
       } catch (Exception e) {
           e.printStackTrace();
       } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1）这里传递的文件名需要是类的全限定性名称，即&lt;code&gt;org.example.classloader.Test&lt;/code&gt;格式的，因为 &lt;code&gt;defineClass&lt;/code&gt; 方法是按这种格式进行处理的。&lt;/p&gt;
&lt;p&gt;2）最好不要重写loadClass方法，因为这样容易破坏双亲委托机制，参考上面&lt;code&gt;loadClass&lt;/code&gt;源码，&lt;code&gt;loadClass&lt;/code&gt;就是双亲委派的实现方法，如果自定义的ClassLoader重写了loadClass，就可能会破会双亲委派机制，所以一般来说重写&lt;code&gt;defineClass&lt;/code&gt;方法即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;四-几种获取classloader的区别&#34;&gt;四、几种获取ClassLoader的区别&lt;/h4&gt;
&lt;p&gt;上面介绍了获取ClassLoader的几种方式，这些方式有哪些区别和联系？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 方式一：获取当前类的 ClassLoader
clazz.getClassLoader()
// 方式二：获取当前线程上下文的 ClassLoader
Thread.currentThread().getContextClassLoader()
// 方式三：获取系统的 ClassLoader
ClassLoader.getSystemClassLoader()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写了个简单demo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
	public static void main(String[] args) {
    // null
    System.out.println(String.class.getClassLoader());
    // sun.misc.Launcher$AppClassLoader@18b4aac2
    System.out.println(MyTest.class.getClassLoader());
    // true
    System.out.println(Thread.currentThread().getContextClassLoader() == MyTest.class.getClassLoader());
    // true  
    System.out.println(Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dubug过程发现，&lt;code&gt;thread.getContextClassLoader()&lt;/code&gt;、&lt;code&gt;clazz.getClassLoader()&lt;/code&gt;以及&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;方法获得的对象是同一个对象 &lt;code&gt;Launcher$AppClassLoader@xxx&lt;/code&gt;，难道这三者只是写法不同，实际上获得的是同一个对象？&lt;/p&gt;
&lt;h5 id=&#34;1-clazzgetclassloader&#34;&gt;1、clazz.getClassLoader&lt;/h5&gt;
&lt;p&gt;通过类对象获取classLoader&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyTest.class.getClassLoader()
// 或者下面这种方式
new MyTest().getClass().getClassLoader();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同类对象的加载器可能是不同的，主要取决于该类是由哪个类加载器加载到JVM中的，比如&lt;code&gt;String.class.getClassLoader&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;，因为&lt;code&gt;java.lang.String&lt;/code&gt;由顶级的引导类加载器加载，而引导类加载器无法通过java代码获取，会返回&lt;code&gt;null&lt;/code&gt;，而开发者自定义的类一般是由&lt;code&gt;应用类加载器加载(AppClassLoader)&lt;/code&gt;，且不同类对象返回的类加载器都是同一个&lt;code&gt;AppClassLoader&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-classloadergetsystemclassloader&#34;&gt;2、ClassLoader.getSystemClassLoader()&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		@CallerSensitive
    public static ClassLoader getSystemClassLoader() {
      	// 初始化SystemClassLoader
        initSystemClassLoader();
        if (scl == null) {
            return null;
        }
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkClassLoaderPermission(scl, Reflection.getCallerClass());
        }
        return scl;
    }

    private static synchronized void initSystemClassLoader() {
        if (!sclSet) {
            if (scl != null)
                throw new IllegalStateException(&amp;quot;recursive invocation&amp;quot;);
            // Launcher对象中初始化了拓展类加载器以及应用类加载器
            sun.misc.Launcher l = sun.misc.Launcher.getLauncher();
            if (l != null) {
                Throwable oops = null;
                // 获取Launcher对象的classLoader设置为scl
                scl = l.getClassLoader();
                try {
                    // 当然，如果&amp;quot;java.system.class.loader&amp;quot;系统属性被定义，可以通过这个系统属性创建新的系统类加载器
                  	// 让scl不再是Launcher对象提供的类加载器，但是Launcher对象的类加载器会作为创建的系统类加载器的父加载器
                    scl = AccessController.doPrivileged(
                        new SystemClassLoaderAction(scl));
                } catch (PrivilegedActionException pae) {
                    oops = pae.getCause();
                    if (oops instanceof InvocationTargetException) {
                        oops = oops.getCause();
                    }
                }
                if (oops != null) {
                    if (oops instanceof Error) {
                        throw (Error) oops;
                    } else {
                        // wrap the exception
                        throw new Error(oops);
                    }
                }
            }
            sclSet = true;
        }
    }

class SystemClassLoaderAction
    implements PrivilegedExceptionAction&amp;lt;ClassLoader&amp;gt; {
    private ClassLoader parent;

    SystemClassLoaderAction(ClassLoader parent) {
        this.parent = parent;
    }

    public ClassLoader run() throws Exception {
        // 获取java.system.class.loader属性
        String cls = System.getProperty(&amp;quot;java.system.class.loader&amp;quot;);
        if (cls == null) {
            return parent;
        }

        Constructor&amp;lt;?&amp;gt; ctor = Class.forName(cls, true, parent)
            .getDeclaredConstructor(new Class&amp;lt;?&amp;gt;[] { ClassLoader.class });
      
      	// 创建类加载器并且设置父加载器
        ClassLoader sys = (ClassLoader) ctor.newInstance(
            new Object[] { parent });
        // 并且会把当前线程的类加载器设置为这个自定义的系统类加载器
        Thread.currentThread().setContextClassLoader(sys);
        return sys;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看getSystemClassLoader方法源码，发现其中有初始化SystemClassLoader相关代码，想看下scl变量是什么时候赋值的，可是debug发现，程序运行过程中并不会进入initSystemClassLoader()的逻辑代码块，scl、sclSet已经被设置过了值，而initSystemClassLoader()方法的调用地方只在getSystemClassLoader()方法中，于是看下getSystemClassLoader方法的注释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Returns the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application.&lt;br&gt;
This method is first invoked early in the runtime&#39;s startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking Thread.&lt;/p&gt;
&lt;p&gt;此方法首先在运行启动序列的早期被调用，此时它创建系统类加载器并将其设置为调用Thread的上下文类加载器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反正这个方法不管被谁调用，都会被调用，如果被调用，就是获取Launcher对象的classLoader设置为scl&lt;/p&gt;
&lt;p&gt;所以Launcher对象是什么？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Launcher {
    // 静态变量，该类被加载的时候就会执行new Launcher();
    private static Launcher launcher = new Launcher();
  
  	// 应用类加载器
    private ClassLoader loader;
  
    public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            // 获取拓展类加载器
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError(&amp;quot;Could not create extension class loader&amp;quot;, var10);
        }

        try {
            // 把var1拓展类加载器作为参数，获取应用类加载器，var1会被设置为应用类加载器的父加载器
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError(&amp;quot;Could not create application class loader&amp;quot;, var9);
        }

        // 这里获取当前线程调用了setContextClassLoader方法，把应用类加载器设置到了当前线程中(就是启动应用的线程)
        // 可见thread.getContextClassLoader获取的默认就是应用类加载器
        Thread.currentThread().setContextClassLoader(this.loader);

    }
  
  
    /**
    * 应用类加载器是Launcher类的一个静态内部类，继承自URLClassLoader
    */
    static class AppClassLoader extends URLClassLoader {
      
        final URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this);

        public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException {
            // 可见AppClassLoader确实是&amp;quot;java.class.path&amp;quot;路径下加载类信息的
            final String var1 = System.getProperty(&amp;quot;java.class.path&amp;quot;);
            final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1);
            return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction&amp;lt;Launcher.AppClassLoader&amp;gt;() {
                public Launcher.AppClassLoader run() {
                    URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2);
                  	// 创建应用类加载器
                    return new Launcher.AppClassLoader(var1x, var0);
                }
            });
        }

        AppClassLoader(URL[] var1, ClassLoader var2) {
            // 会把var2,即ExtClassLoader对象设置为parent
            super(var1, var2, Launcher.factory);
            this.ucp.initLookupCache(this);
        }
    }

    /**
    * 拓展类加载器是Launcher类的一个静态内部类，继承自URLClassLoader
    */
    static class ExtClassLoader extends URLClassLoader {
      
        private static volatile Launcher.ExtClassLoader instance;

        public static Launcher.ExtClassLoader getExtClassLoader() throws IOException {
            if (instance == null) {
                Class var0 = Launcher.ExtClassLoader.class;
                synchronized(Launcher.ExtClassLoader.class) {
                    if (instance == null) {
                        instance = createExtClassLoader();
                    }
                }
            }
            return instance;
        }

        private static Launcher.ExtClassLoader createExtClassLoader() throws IOException {
            try {
                return (Launcher.ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Launcher.ExtClassLoader&amp;gt;() {
                    public Launcher.ExtClassLoader run() throws IOException {
                      	// 在&amp;quot;java.ext.dirs&amp;quot;路径下找class文件
                        File[] var1 = Launcher.ExtClassLoader.getExtDirs();
                        int var2 = var1.length;

                        for(int var3 = 0; var3 &amp;lt; var2; ++var3) {
                            MetaIndex.registerDirectory(var1[var3]);
                        }
												// 创建拓展类加载器
                        return new Launcher.ExtClassLoader(var1);
                    }
                });
            } catch (PrivilegedActionException var1) {
                throw (IOException)var1.getException();
            }
        }

        public ExtClassLoader(File[] var1) throws IOException {
            super(getExtURLs(var1), (ClassLoader)null, Launcher.factory);
            SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this);
        }

        private static File[] getExtDirs() {
            String var0 = System.getProperty(&amp;quot;java.ext.dirs&amp;quot;);
            File[] var1;
            if (var0 != null) {
                StringTokenizer var2 = new StringTokenizer(var0, File.pathSeparator);
                int var3 = var2.countTokens();
                var1 = new File[var3];

                for(int var4 = 0; var4 &amp;lt; var3; ++var4) {
                    var1[var4] = new File(var2.nextToken());
                }
            } else {
                var1 = new File[0];
            }

            return var1;
        }
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对sun.misc.Launcher类debug，发现断点也是进不去的，好吧，反正这个类肯定是会在应用启动的时候被加载的，从上面demo中打印出的classloader对象&lt;code&gt;sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/code&gt;也可以看出AppClassLoader就来自于sun.misc.Launcher。&lt;/p&gt;
&lt;p&gt;搜索一番资料后发现一句话，&lt;strong&gt;&amp;quot;扩展类加载器&amp;quot;和&amp;quot;应用类加载器&amp;quot;都是由&amp;quot;启动类加载器&amp;quot;加载的&lt;/strong&gt;，就认为是启动类加载器加载了Launcher这个类吧。&lt;/p&gt;
&lt;h5 id=&#34;3-threadgetcontextclassloader&#34;&gt;3、thread.getContextClassLoader&lt;/h5&gt;
&lt;p&gt;即当前线程中的类加载器，根据上文描述，可以看到ContextClassLoader是如何被赋值的&lt;/p&gt;
&lt;h5 id=&#34;总结&#34;&gt;总结&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;1、一般情况下，clazz.getClassLoader = ClassLoader.getSystemClassLoader() = thread.getContextClassLoader = AppClassLoader&lt;/p&gt;
&lt;p&gt;ps：这里的clazz对象不是由启动类加载器或者拓展类加载器加载的类，比如不是java.lang.String&lt;/p&gt;
&lt;p&gt;2、如果设置了&amp;quot;java.system.class.loader&amp;quot;属性，那么会创建&lt;code&gt;自定义系统类加载器&lt;/code&gt;，这个系统类加载器的&lt;code&gt;父加载器&lt;/code&gt;就是AppClassLoader，同时把当前线程的类加载器设置为这个自定义的系统类加载器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;五-threadcontextclassloader的作用&#34;&gt;五、ThreadContextClassLoader的作用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ThreadContextClassLoader&lt;/code&gt;就是指上文的&lt;code&gt;thread.getContextClassLoader&lt;/code&gt;，下文简称为&lt;code&gt;TCCL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过上文看到TTCL就是Java放到线程里的应用类加载器，为什么要放到线程中？直接使用&lt;code&gt;clazz.getClassLoader&lt;/code&gt;不就行了？有什么用途？&lt;/p&gt;
&lt;h5 id=&#34;1-反向委派机制&#34;&gt;1、反向委派机制&lt;/h5&gt;
&lt;p&gt;Java提供了很多接口，比如SPI相关的接口，JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由启动类加载器加载。Java只提供接口，这些接口的具体实现由不同厂商去实现，以JDBC为例，有连接MySQL的，也有连接ORACLE的，使用Java语言操作数据库，我们习惯于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;  //步骤1：加载驱动(mysql)
	Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
  //SQL Server 连接：com.microsoft.sqlserver.jdbc.SQLServerDriver
  //Oracle 连接：oracle.jdbc.driver.OracleDriver

	 //步骤2：得到连接
	 Connection conn = DriverManager.getConnection(&amp;quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;quot;, &amp;quot;root&amp;quot;,&amp;quot;root&amp;quot;);
	 
  //步骤3：得到执行sql语句的对象
	PreparedStatement pstmt =  conn.prepareStatement(&amp;quot;select * from xxx&amp;quot;);
	// ...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果操作MySQL，那么就需要引入MySQL的驱动依赖的jar包&lt;code&gt;mysql-connector-java-xxx&lt;/code&gt;，在程序运行的时候主动加载驱动器&lt;code&gt;Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code&gt;，那么就可以操作MySQL数据库了。&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;Java1.6&lt;/code&gt;开始自带的&lt;code&gt;jdbc4.0&lt;/code&gt;版本已支持&lt;code&gt;SPI&lt;/code&gt;服务加载机制，只要MySQL的驱动依赖的jar包在类路径中，就可以注册MySQL驱动，也就是说可以不用主动加载驱动&lt;code&gt;Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code&gt;，这行代码不要也行，怎么做到的呢？&lt;/p&gt;
&lt;p&gt;先了解一下什么是&lt;code&gt;SPI&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SPI机制简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPI的全名为Service Provider Interface，主要是应用于厂商自定义组件或插件中。在java.util.ServiceLoader的文档里有比较详细的介绍。简单的总结下java SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPI具体约定&lt;/strong&gt;&lt;br&gt;
Java SPI的具体约定为：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，Java定义了接口，厂商的实现类只要按照规定放在指定的位置，Java就能自动扫描并加载到该实现类。&lt;/p&gt;
&lt;p&gt;回顾一下Java不同类加载器加载的路径范围，会发现默认情况下没有一个类加载器能主动加载第三方jar包中的类，那么Java是如何做到的呢？以上面的&lt;code&gt;DriverManager&lt;/code&gt;为例分析&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DriverManager {
    static {
        // DriverManager被加载时调用，上面写的代码中显示的调用了DriverManager，所以就会加载该类
        loadInitialDrivers();
        println(&amp;quot;JDBC DriverManager initialized&amp;quot;);
    }
  
    private static void loadInitialDrivers() {
        String drivers;
        try {
            drivers = AccessController.doPrivileged(new PrivilegedAction&amp;lt;String&amp;gt;() {
                public String run() {
                    // 尝试从系统属性&amp;quot;jdbc.drivers&amp;quot;获取驱动器信息
                    return System.getProperty(&amp;quot;jdbc.drivers&amp;quot;);
                }
            });
        } catch (Exception ex) {
            drivers = null;
        }
        // If the driver is packaged as a Service Provider, load it.
        // Get all the drivers through the classloader
        // exposed as a java.sql.Driver.class service.
        // ServiceLoader.load() replaces the sun.misc.Providers()

        AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
            public Void run() {
                // ServiceLoader对象会去扫描classpath下包括依赖引入的jar包，所有的META-INF/services/java.sql.Driver文件，取出其中的全限定类名，加载该类，并且实例化。
                ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator();

                /* Load these drivers, so that they can be instantiated.
                 * It may be the case that the driver class may not be there
                 * i.e. there may be a packaged driver with the service class
                 * as implementation of java.sql.Driver but the actual class
                 * may be missing. In that case a java.util.ServiceConfigurationError
                 * will be thrown at runtime by the VM trying to locate
                 * and load the service.
                 *
                 * Adding a try catch block to catch those runtime errors
                 * if driver not available in classpath but it&#39;s
                 * packaged as service and that service is there in classpath.
                 */
                try{
                    // 真正的逻辑在这，下面会有详细源码解释
                    while(driversIterator.hasNext()) {
                        driversIterator.next();
                    }
                } catch(Throwable t) {
                // Do nothing
                }
                return null;
            }
        });
      
        println(&amp;quot;DriverManager.initialize: jdbc.drivers = &amp;quot; + drivers);
				
      	// 如果系统属性&amp;quot;jdbc.drivers&amp;quot;没有人为指定Driver信息，这里就直接返回了
        // 如果有，下面就会遍历、加载这些类
        if (drivers == null || drivers.equals(&amp;quot;&amp;quot;)) {
            return;
        }
        String[] driversList = drivers.split(&amp;quot;:&amp;quot;);
        println(&amp;quot;number of Drivers:&amp;quot; + driversList.length);
        for (String aDriver : driversList) {
            try {
                println(&amp;quot;DriverManager.Initialize: loading &amp;quot; + aDriver);
                Class.forName(aDriver, true,
                        ClassLoader.getSystemClassLoader());
            } catch (Exception ex) {
                println(&amp;quot;DriverManager.Initialize: load failed: &amp;quot; + ex);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ServiceLoader源码重点分析&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 重点步骤标记上了记号 ①②③④
AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
    public Void run() {
        ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class); // ①
        Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator(); // ②
      
        try{
            while(driversIterator.hasNext()) { // ③
                driversIterator.next(); // ④
            }
        } catch(Throwable t) {
        // Do nothing
        }
        return null;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;① 构建一个ServiceLoader对象，同时初始化一个延迟迭代器，在这个过程中，获取了TTCL，TTCL以及参数传入的java.sql.Driver.class都被传入了延迟迭代器对象中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service) {
		// 获取TTCL，主角出现！！！
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    // 继续调用load方法
    return ServiceLoader.load(service, cl);
}

public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service,
                                        ClassLoader loader)
{
    return new ServiceLoader&amp;lt;&amp;gt;(service, loader);
}

private ServiceLoader(Class&amp;lt;S&amp;gt; svc, ClassLoader cl) {
    // serveice即成员变量Class&amp;lt;S&amp;gt; service，这里被赋值为 Class&amp;lt;java.sql.Driver&amp;gt;
    service = Objects.requireNonNull(svc, &amp;quot;Service interface cannot be null&amp;quot;);
    // load即成员变量ClassLoader loader，被赋值为TTCL
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
    // 创建延迟迭代器LazyIterator
    reload();
}

public void reload() {
    providers.clear();
  	// lookupIterator即成员变量LazyIterator lookupIterator
    lookupIterator = new LazyIterator(service, loader);
}

/**
* LazyIterator是ServiceLoader的一个静态内部类
* 就是这个类完成了资源的加载，下面会分析这个类
*/
private class LazyIterator implements Iterator&amp;lt;S&amp;gt; {

    Class&amp;lt;S&amp;gt; service;
    ClassLoader loader;
    Enumeration&amp;lt;URL&amp;gt; configs = null;
    Iterator&amp;lt;String&amp;gt; pending = null;
    String nextName = null;

    private LazyIterator(Class&amp;lt;S&amp;gt; service, ClassLoader loader) {
      	// TTCL以及参数传入的java.sql.Driver.class都被传入了延迟迭代器对象中
        this.service = service;
        this.loader = loader;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 该方法返回一个匿名内部类实例的迭代器，内部真正工作的迭代器就是上面①创建出的延迟迭代器LazyIterator&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterator&amp;lt;S&amp;gt; iterator() { return new Iterator&amp;lt;S&amp;gt;() {
				
  			// providers是ServiceLoader的成员变量，LinkedHashMap&amp;lt;String,S&amp;gt; providers = new LinkedHashMap&amp;lt;&amp;gt;();
  			// 不明白这个变量knownProviders放在这里有什么意义？
  			// 因为起初providers为空，所以使用一个空集合构建的knownProviders，hashNext()方法会一直false，即使后面providers有数据了，但是knownProviders.hashNext()也会false
  			// 甚至如果使用不当，还可能会抛出 java.util.ConcurrentModificationException 异常
        Iterator&amp;lt;Map.Entry&amp;lt;String, S&amp;gt;&amp;gt; knownProviders = providers.entrySet().iterator();

  			/**
  			* knownProviders有就返回true，没有就去调用延迟迭代器的hasNext()
  			*/
        public boolean hasNext() {
            if (knownProviders.hasNext())
                return true;
            // 这个lookupIterator就是ServiceLoader的成员变量，①中创建的延迟迭代器LazyIterator
            return lookupIterator.hasNext();
        }

  			/**
  			* knownProviders有就返回，没有就调用lookupIterator.next()
  			*/
        public S next() {
            if (knownProviders.hasNext())
                return knownProviders.next().getValue();
            return lookupIterator.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 使用延迟迭代器获取&lt;code&gt;&amp;quot;META-INF/services/java.sql.Driver&amp;quot;&lt;/code&gt;文件，解析文件内容，将文件内容保存在&lt;code&gt;nextName&lt;/code&gt;变量中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean hasNext() {
    if (knownProviders.hasNext())
        return true;
  	// knownProviders.hashNext应该会一直false，所以会进入lookupIterator.hasNext()
    return lookupIterator.hasNext();
}

public boolean hasNext() {
    if (acc == null) {
      	// 加载资源文件，获取文件中的数据
        return hasNextService();
    } else {
        PrivilegedAction&amp;lt;Boolean&amp;gt; action = new PrivilegedAction&amp;lt;Boolean&amp;gt;() {
            public Boolean run() { return hasNextService(); }
        };
        return AccessController.doPrivileged(action, acc);
    }
}

private boolean hasNextService() {
  	// nextName起初为空
    if (nextName != null) {
        return true;
    }
  	// configs起初为空，configs为LazyIterator对象的成员变量Enumeration&amp;lt;URL&amp;gt; configs
    if (configs == null) {
        try {
          	// fullName = &amp;quot;META-INF/services/&amp;quot; + &amp;quot;java.sql.Driver&amp;quot;
            String fullName = PREFIX + service.getName();
            if (loader == null)
                configs = ClassLoader.getSystemResources(fullName);
            else
              	// 获取classpath下所有工程包括jar包中的所有&amp;quot;META-INF/services/java.sql.Driver&amp;quot;文件资源
                configs = loader.getResources(fullName);
        } catch (IOException x) {
            fail(service, &amp;quot;Error locating configuration files&amp;quot;, x);
        }
    }
  	// pending为LazyIterator对象的成员变量Iterator&amp;lt;String&amp;gt; pending，起初为空
  	// 用于保存&amp;quot;META-INF/services/java.sql.Driver&amp;quot;文件解析出来的字符串
    while ((pending == null) || !pending.hasNext()) {
        if (!configs.hasMoreElements()) {
            return false;
        }
      	// 解析&amp;quot;META-INF/services/java.sql.Driver&amp;quot;文件，具体源码不看了，就是文件流的操作
        pending = parse(service, configs.nextElement());
    }
  	// 有个小疑问？pending虽然是个List&amp;lt;String&amp;gt;的迭代器，理论上可能会存在多条记录，但是由于上面while(!pending.hasNext())的条件限制
  	// 导致即使一个&amp;quot;META-INF/services/java.sql.Driver&amp;quot;文件中包含多行记录，也只会执行一次pending.next()，即nextName只会取java.sql.Driver文件中的第一行记录。
    nextName = pending.next();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;项目pom依赖中引入了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;8.0.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看一眼&lt;code&gt;&amp;quot;META-INF/services/java.sql.Driver&amp;quot;&lt;/code&gt;文件中是啥？所以，nextName就会赋值为&lt;code&gt;&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/image-20220711140801067.png&#34; alt=&#34;image-20220711140801067&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;④ 加载③获取到的class，并且实例化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public S next() {
    if (knownProviders.hasNext())
        return knownProviders.next().getValue();
  	// knownProviders.hashNext应该会一直false，所以会进入lookupIterator.next()
    return lookupIterator.next();
}

public S next() {
    if (acc == null) {
      	// 加载步骤③获取到的class，并且实例化
        return nextService();
    } else {
        PrivilegedAction&amp;lt;S&amp;gt; action = new PrivilegedAction&amp;lt;S&amp;gt;() {
            public S run() { return nextService(); }
        };
        return AccessController.doPrivileged(action, acc);
    }
}

private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
  	// nextName = &amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;
    String cn = nextName;
  	// 把nextName置空为了下一次遍历找新的文件
    nextName = null;
    Class&amp;lt;?&amp;gt; c = null;
    try {
      	// 仅加载&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;，并不执行该类的初始化，即不会执行com.mysql.cj.jdbc.Driver类的静态代码块
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service, &amp;quot;Provider &amp;quot; + cn + &amp;quot; not found&amp;quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service, &amp;quot;Provider &amp;quot; + cn  + &amp;quot; not a subtype&amp;quot;);
    }
    try {
      	// 反射创建&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;实例，同时也会去执行该类的静态代码块，调用java.sql.DriverManager.registerDriver(new Driver())方法，到这里整个过程也就结束了
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service, &amp;quot;Provider &amp;quot; + cn + &amp;quot; could not be instantiated&amp;quot;, x);
    }
    throw new Error();          // This cannot happen
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、程序内显示调用DriverManager.getConnection触发DriverManager类的初始化，满足SPI的约定情况下，使用ServiceLoader到指定位置扫描第三方jar包中的实现类加载以及实例化。&lt;/p&gt;
&lt;p&gt;2、扫描资源时，使用的是classLoader.getResources()方法，会返回classpath下所有&lt;code&gt;&amp;quot;META-INF/services/java.sql.Driver&amp;quot;&lt;/code&gt;的资源文件，其中classLoader是TTCL，也就是反向委派机制的主角，启动类加载器和拓展类加载器加载不了的类，那就下派到TTCL去加载，TTCL是什么，一般情况下就是程序启动时把&lt;code&gt;应用类加载器AppClassLoader&lt;/code&gt;放到了当前线程。&lt;/p&gt;
&lt;p&gt;3、关于TTCL有没有破坏双亲委派机制的争议？从大的角度来看，启动类加载器和拓展类加载器加载不了的类，下派到TTCL去加载，似乎是破坏了原有的类加载流程，但是根据上文中介绍的双亲委派机制，可以发现，双亲委派的是由&lt;code&gt;loadClass()&lt;/code&gt;方法实现的，而这里获取到的TTCL并没有重写loadClass方法，一般情况下TTCL就是AppClassLoader，日常开发中程序代码中也会经常地使用TTCL、AppClassLoader加载类，所以这也算是破坏双亲委派机制？因此，我更愿意把TTCL当做程序&lt;code&gt;反向委派&lt;/code&gt;的一种手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;2-tomcat类加载&#34;&gt;2、Tomcat类加载&lt;/h5&gt;
&lt;p&gt;参考 https://blog.csdn.net/yangcheng33/article/details/52631940 相关描述&lt;/p&gt;
&lt;h5 id=&#34;3-spring类加载&#34;&gt;3、Spring类加载&lt;/h5&gt;
&lt;p&gt;参考 https://blog.csdn.net/yangcheng33/article/details/52631940 相关描述&lt;/p&gt;
&lt;h4 id=&#34;六-热加载hotswap&#34;&gt;六、热加载HotSwap&lt;/h4&gt;
&lt;h5 id=&#34;1-tomcat的热加载&#34;&gt;1、Tomcat的热加载&lt;/h5&gt;
&lt;p&gt;参考 https://blog.csdn.net/admin522043032/article/details/124688069&lt;/p&gt;
&lt;h5 id=&#34;2-java程序如何实现hotswap&#34;&gt;2、Java程序如何实现HotSwap&lt;/h5&gt;
&lt;p&gt;参考 https://www.jianshu.com/p/3bc46de006da&lt;/p&gt;
&lt;h4 id=&#34;七-getresource与getresources&#34;&gt;七、getResource与getResources&lt;/h4&gt;
&lt;p&gt;测试demo，项目结构如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;demo
	|
	main
		|
		src
			|
			java
				|
				org.example
					|
					MyTest.java
			resources
				|
				spring.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
    public static void main(String[] args) throws Exception {
        // null
        System.out.println(MyTest.class.getResource(&amp;quot;spring.xml&amp;quot;));
        // file:/Users/xxx/xxx/demo/target/classes/spring.xml
        System.out.println(MyTest.class.getResource(&amp;quot;../../../spring.xml&amp;quot;));
        // file:/Users/xxx/xxx/demo/target/classes/spring.xml
        System.out.println(MyTest.class.getResource(&amp;quot;/spring.xml&amp;quot;));
        System.out.println(&amp;quot;---------------&amp;quot;);

        // file:/Users/xxx/xxx/demo/target/classes/spring.xml
        System.out.println(MyTest.class.getClassLoader().getResource(&amp;quot;spring.xml&amp;quot;));
        // null
        System.out.println(MyTest.class.getClassLoader().getResource(&amp;quot;/spring.xml&amp;quot;));
        System.out.println(&amp;quot;---------------&amp;quot;);

        Enumeration&amp;lt;URL&amp;gt; urls1 = MyTest.class.getClassLoader().getResources(&amp;quot;spring.xml&amp;quot;);
        while (urls1.hasMoreElements()) {
            System.out.println(urls1.nextElement());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;1-clazzgetresource与classloadergetresource&#34;&gt;1、clazz.getResource与classLoader.getResource&lt;/h5&gt;
&lt;p&gt;点开clazz.getResource源码看了下，发现clazz.getResource实际上就是调用了classLoader.getResource，只不过调用之前，处理了一下路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public java.net.URL getResource(String name) {
  	// 处理路径
    name = resolveName(name);
    ClassLoader cl = getClassLoader0();
    if (cl==null) {
        // A system class.
        return ClassLoader.getSystemResource(name);
    }
    return cl.getResource(name);
}

/**
 * Add a package name prefix if the name is not absolute Remove leading &amp;quot;/&amp;quot;
 * if name is absolute
 */
private String resolveName(String name) {
    if (name == null) {
        return name;
    }
    if (!name.startsWith(&amp;quot;/&amp;quot;)) {
      	// 如果不以&amp;quot;/&amp;quot;开头，就获取当前类全限定类名，将&amp;quot;.&amp;quot;替换为&amp;quot;/&amp;quot;，从当前类的所在目录下检索资源
      	// 如clazz.getResource(&amp;quot;spring.xml&amp;quot;)，clazz为org.example.MyTest.class，经过处理后就变成了，从类路径下寻找org/example/spring.xml文件
      	// 十有八九是找不到的，所以建议clazz.getResource(name)，name以&amp;quot;/&amp;quot;开头，除非你就是想在当前类所在的目录下找这个文件。
        Class&amp;lt;?&amp;gt; c = this;
        while (c.isArray()) {
            c = c.getComponentType();
        }
        String baseName = c.getName();
        int index = baseName.lastIndexOf(&#39;.&#39;);
        if (index != -1) {
            name = baseName.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)
                +&amp;quot;/&amp;quot;+name;
        }
    } else {
      	// 以&amp;quot;/&amp;quot;开头就截取&amp;quot;/&amp;quot;后字符串返回
        name = name.substring(1);
    }
    return name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-classloadergetresource和classloadergetresources&#34;&gt;2、classLoader.getResource和classLoader.getResources&lt;/h5&gt;
&lt;p&gt;getResource是从classpath下寻找资源文件，只在当前项目的&lt;code&gt;classes/&lt;/code&gt;下寻找，不会去寻找依赖的jar包中的文件；&lt;/p&gt;
&lt;p&gt;getResources是从classpath下寻找所有符合资源路径名称的文件，包括依赖的jar包下的文件；&lt;/p&gt;
&lt;p&gt;为了看出getResources的效果，本地又新建了另外的一个项目haha，haha项目的resource目录下也包含一个spring.xml，当haha项目使用maven打包到本地maven仓库后，生成&lt;code&gt;/Users/xxx/maven/maven_repository/org/example/haha/1.0-SNAPSHOT/haha-1.0-SNAPSHOT.jar&lt;/code&gt;，原resource目录下的spring.xml会被放到这个jar包的&lt;code&gt;classes/&lt;/code&gt;文件夹下。&lt;/p&gt;
&lt;p&gt;所以，当demo项目引入了haha的依赖后，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;haha&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
    public static void main(String[] args) throws Exception {
        // 打印一下当前项目classpath路径包括哪些jar包以及项目
      	// 其中就包含 /Users/xxx/maven/maven_repository/org/example/haha/1.0-SNAPSHOT/haha-1.0-SNAPSHOT.jar
        System.out.println(System.getProperty(&amp;quot;java.class.path&amp;quot;));

      	System.out.println(&amp;quot;---------------&amp;quot;);
      
      	// 会找到classpath下所有的spring.xml文件
        Enumeration&amp;lt;URL&amp;gt; urls1 = MyTest.class.getClassLoader().getResources(&amp;quot;spring.xml&amp;quot;);
        while (urls1.hasMoreElements()) {
            System.out.println(urls1.nextElement());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home/jre/lib/charsets.... 后面省略
---------------
file:/Users/xxx/xxx/demo/target/classes/spring.xml
jar:file:/Users/xxx/maven/maven_repository/org/example/haha/1.0-SNAPSHOT/haha-1.0-SNAPSHOT.jar!/spring.xml
&lt;/code&gt;&lt;/pre&gt;
">Java类加载</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://boild-water.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://boild-water.github.io/post/linux-xia-an-zhuang-apache-server/"" data-c="
          &lt;h3 id=&#34;linux下安装apache-server用于当做个人图片服务器&#34;&gt;Linux下安装Apache Server（用于当做个人图片服务器）&lt;/h3&gt;
&lt;h4 id=&#34;1安装apache-server&#34;&gt;1.安装Apache Server&lt;/h4&gt;
&lt;p&gt;​		下载压缩包编译方式，由于需要下载各种依赖包，解决好依赖问题，才能安装成功，过程较为繁琐，这里直接使用yum方式进行安装，自动解决了依赖包问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install httpd （安装过程，输入y）
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/20201225134843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		出现下面页面即表示安装成功&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/20201225134952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2配置apache-server&#34;&gt;2.配置Apache Server&lt;/h4&gt;
&lt;p&gt;​		安装成功后，配置文件会被放在/etc/httpd/conf/目录下，进入该目录，编辑配置文件httpd.cnf，最好先备份一下该配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/httpd/conf/
cp httpd.cnf httpd_back.cnf
vim httpd.cnf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		在配置文件中添加配置项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;# 图片目录 &amp;quot;/opt/images&amp;quot; 指向磁盘的物理地址 标签内表示权限信息
&amp;lt;Directory &amp;quot;/opt/boildwater/images&amp;quot;&amp;gt;
    AllowOverride none
    Require all granted
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		在&lt;IfModule alias_module&gt;&lt;/IfModule&gt;标签下添加别名映射信息，为/opt/boildwater/images指定一个访问别名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;Alias /boildwater/images /opt/boildwater/images
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		配置完成后，配置文件如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;# 图片目录 &amp;quot;/opt/images&amp;quot; 指向磁盘的物理地址 标签内表示权限信息
&amp;lt;Directory &amp;quot;/opt/boildwater/images&amp;quot;&amp;gt;
    AllowOverride none
    Require all granted
&amp;lt;/Directory&amp;gt;

&amp;lt;IfModule alias_module&amp;gt;
    #
    # Redirect: Allows you to tell clients about documents that used to 
    # exist in your server&#39;s namespace, but do not anymore. The client 
    # will make a new request for the document at its new location.
    # Example:
    # Redirect permanent /foo http://www.example.com/bar

    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a &amp;lt;Directory&amp;gt; section to allow access to
    # the filesystem path.

    #
    # ScriptAlias: This controls which directories contain server scripts. 
    # ScriptAliases are essentially the same as Aliases, except that
    # documents in the target directory are treated as applications and
    # run by the server when requested rather than as documents sent to the
    # client.  The same rules about trailing &amp;quot;/&amp;quot; apply to ScriptAlias
    # directives as to Alias.
    #
    ScriptAlias /cgi-bin/ &amp;quot;/var/www/cgi-bin/&amp;quot;

    # 图片地址alias
    Alias /boildwater/images /opt/boildwater/images

&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3启动apache-server&#34;&gt;3.启动Apache Server&lt;/h4&gt;
&lt;p&gt;​		启动apche server （前提是80端口不能被其他服务占用），查看80端口是否被占用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;netstat -atunp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		确保Local Address没有80端口即可&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Boild-Water/image_from_picgo/main/notes/20201225135059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		启动apache server&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl start httpd.service	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		为什么确保80端口不被其他服务占用，查看配置文件httpd.cnf能看到apache server的默认端口为80&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;#
# Listen: Allows you to bind Apache to specific IP addresses and/or
# ports, instead of the default. See also the &amp;lt;VirtualHost&amp;gt;
# directive.
#
# Change this to Listen on specific IP addresses as shown below to 
# prevent Apache from glomming onto all bound IP addresses.
#
#Listen 12.34.56.78:80
Listen 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		所以在启动服务后，直接在浏览器中输入 &lt;strong&gt;ip地址/配置的目录访问别名/xxx.png&lt;/strong&gt; 就可以访问到存放的图片资源了，比如我访问图片就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xx.xx.xxx.xx/boildwater/images/demo.png&lt;/strong&gt;&lt;/p&gt;
">Linux下安装Apache Server</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://boild-water.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






  <div class="snow-container"></div>
  <script color="0,205,205" pointer-events="auto" zIndex="-1" opacity='0.7' count="99" src="/media/js/bg/canvas-nest.js"></script>


</html>